<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Binary Abacus</title>
    <style>
        body {
            margin-top: 50px;
            font-family: Arial, sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            min-width: fit-content;
            width: 100%;
        }
        /* Color gradient for the abacus beads/place value indicators */
        .column-gradient {
            background: linear-gradient(to right, #ff0000, #cc00ff);
            color: linear-gradient(to right, #ff0000, #cc00ff);
        }

        .abacus {
            margin-top: 20px;
        }
        .header, .row {
            display: flex;
            margin-bottom: 10px;
        }
        .header-cell, .row-total {
            /* border: 1px solid #333; */
            text-align: center;
            padding: 11px;
            margin: 2px;
        }
        .header-cell {
            width: 50px;
            font-weight: bold;
            background-color: #fcfcfc;
        }
        .row {
            /* border-top: 10px solid #ddd; */
            border-bottom: 10px solid #ddd;
        }
        .row:nth-child(even), .row:nth-child(even) .row-total {
            background-color: #f0f0f0;
        }

        .bead {
            text-align: center;
            padding: 10px;
            margin: 2px;
            width: 50px;
            margin-top: 32px;
            height: 15px;
            cursor: pointer;
            color: #fff;
            border: 1px solid #888;
            background-color: #333; /* natural bead color */
            border-radius: 5px;
            transition: transform 0.15s ease-in-out;
            transform: translateY(0);
            position: relative; /* ensure any absolutely positioned children are relative thereto */
        }
        .blank-space {
            width: 50px;
            height: 50px;
            line-height: 50px;
            padding: 11px;
            margin: 2px;
        }
        .bead.active {
            background-color: #fff;
            transform: translateY(-30px);
            color: #000;
        }
        .row-total {
            padding-top: 25px;
            width: 50px;
            background-color: #ffffff;
            font-weight: bold;
        }
        .controls {
            position: absolute;
            top: 15px;
            left: 15px;
            background-color: #eeeC;
            display: flex;
            flex-direction: column;
            /* color: #000; */
            border: 1px solid #888;
            padding: 10px;
            border-radius: 5px;
        }
        .controls span {
            display: flex;
            justify-content: space-between;
            align-items: center;
            width: 100%;
            margin-bottom: 5px;
        }
        .controls label {
            margin-right: 10px;
        }
        .controls input {
            width: 50px;
            margin-left: auto;
        }

        /* New styling for keyboard overlay */
        .key-label {
            position: absolute;
            top: 2px;
            right: 2px;
            font-size: 10px;
            color: rgba(255,255,255,0.7);
            pointer-events: none;
        }
    </style>
</head>
<body>
    <div class="controls">
        <span>
            <label for="columnCount">Columns:</label>
            <input type="number" id="columnCount" value="8" min="1">
        </span>
        <span>
            <label for="rowCount">Rows:</label>
            <input type="number" id="rowCount" value="3" min="1">
        </span>
        <span>
            <label for="showDigits">Show Digits</label>
            <input type="checkbox" id="showDigits">
        </span>
        <span>
            <label for="hidePlaceValues">Hide Place Values</label>
            <input type="checkbox" id="hidePlaceValues">
        </span>
        <span>
            <button id="showKeyboard(Ctrl)">Show Keyboard</button>
        </span>
    </div>
    <h1>Binary Abacus</h1>
    <div class="abacus">
        <!-- Abacus will be generated dynamically -->
    </div>

    <script>
        let registers = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];   
        let columns = 8;
        let rows = 2;
        const snapSound = new Audio('snap.mp3');
        // Function to generate the abacus dynamically based on the number of columns
        function generateAbacus(columns, rows) {
            const abacusEl = document.querySelector('.abacus');
            let html = '';
            // Generate the header row with binary place values (descending order)
            html += '<div class="header">';
            for (let i = columns - 1; i >= 0; i--) {
                const value = Math.pow(2, i);
                html += `<div class="header-cell">${document.getElementById('hidePlaceValues').checked ? '' : value}</div>`;
            }
            // for the first column, 
            html += '<div class="header-cell">Total</div></div>';

            // Create 3 rows by default, each with the specified number of beads
            for (let r = 0; r < rows; r++) {
                html += '<div class="row">';
                for (let i = columns - 1; i >= 0; i--) {
                    const value = Math.pow(2, i);
                    html += `<div class="bead" data-value="${value}" data-bit="0">${document.getElementById('showDigits').checked ? "0" : ""}</div>`;
                }
                html += '<div class="row-total">0</div></div>';
            }

            abacusEl.innerHTML = html;
        }

        // Update the decimal total for a given row by summing the values of active beads.
        function updateRowTotal(row) {
            let total = 0;
            row.querySelectorAll('.bead').forEach(function(bead) {
                if (bead.dataset.bit === "1") {
                    total += parseInt(bead.dataset.value, 10);
                }
            });
            row.querySelector('.row-total').textContent = total;
        }

        document.getElementById('columnCount').addEventListener('change', function() {
            const newColumns = parseInt(document.getElementById('columnCount').value);
            if (isNaN(newColumns) || newColumns < 1) {
                alert("Please enter a valid number of columns (minimum 1).");
                return;
            }
            columns = newColumns;
            generateAbacus(columns, rows);
        });

        document.getElementById('rowCount').addEventListener('change', function() {
            const newRows = parseInt(document.getElementById('rowCount').value);
            if (isNaN(newRows) || newRows < 1) {
                alert("Please enter a valid number of rows (minimum 1).");
                return;
            }
            rows = newRows;
            generateAbacus(columns, rows);
        });

        
        // Initialize the abacus with the default 8 columns.
        generateAbacus(columns, rows);

        // Update beads' text when the Show Digits checkbox is toggled.
        document.getElementById('showDigits').addEventListener('change', function() {
            const show = this.checked;
            document.querySelectorAll('.bead').forEach(function(bead) {
                bead.textContent = show ? (bead.dataset.bit === "1" ? "1" : "0") : '';
            });
        });

        // --- Begin Swipe and Keyboard Input Functionality ---

        // Global variables for swipe input
        let isMouseDown = false;
        let swipeAction = "";
        let visitedBeads = new WeakSet();

        // Function to apply an action to a bead (used in swipe and keyboard)
        function applySwipeAction(bead, action) {
            const originalBit = bead.dataset.bit;
            if (action === "set") {
                bead.classList.add('active');
                bead.dataset.bit = "1";
            } else if (action === "unset") {
                bead.classList.remove('active');
                bead.dataset.bit = "0";
            } else if (action === "toggle") {
                if (bead.classList.contains('active')) {
                    bead.classList.remove('active');
                    bead.dataset.bit = "0";
                } else {
                    bead.classList.add('active');
                    bead.dataset.bit = "1";
                }
            }
            if (originalBit !== bead.dataset.bit) {
                snapSound.currentTime = 0;
                snapSound.play();
            }
            if(document.getElementById('showDigits').checked) {
                bead.textContent = bead.dataset.bit === "1" ? "1" : "0";
            } else {
                bead.textContent = "";
            }
            updateRowTotal(bead.closest('.row'));
        }

        const abacusEl = document.querySelector('.abacus');

        // Prevent the context menu so right-click can be used for toggling
        abacusEl.addEventListener('contextmenu', function(event) {
            event.preventDefault();
        });

        // Mouse down event: start swipe action on a bead
        abacusEl.addEventListener('mousedown', function(event) {
            if (event.target.classList.contains('bead')) {
                event.preventDefault();
                isMouseDown = true;
                visitedBeads = new WeakSet();
                if (event.button === 0) { // Primary button
                    swipeAction = event.target.classList.contains('active') ? "unset" : "set";
                    applySwipeAction(event.target, swipeAction);
                } else if (event.button === 2) { // Secondary button
                    swipeAction = "toggle";
                    applySwipeAction(event.target, swipeAction);
                }
            }
        });

        // Mouse over event: if swiping, apply the current swipeAction to new beads
        abacusEl.addEventListener('mouseover', function(event) {
            if (isMouseDown && event.target.classList.contains('bead')) {
                if (!visitedBeads.has(event.target)) {
                    visitedBeads.add(event.target);
                    applySwipeAction(event.target, swipeAction);
                }
            }
        });

        // Mouse up: end the swipe action
        window.addEventListener('mouseup', function(event) {
            isMouseDown = false;
            visitedBeads = new WeakSet();
            swipeAction = "";
        });

        // Keyboard input: map key rows to beads in each row
        const keyMap = ["qwertyuiop", "asdfghjkl;", "zxcvbnm,.", "1234567890"];

        // New: Use Up and Down arrow keys as modifiers.
        // When the up arrow is held, we'll set (activate) beads.
        // When the down arrow is held, we'll unset (clear) beads.
        let keyModifier = "";
        window.addEventListener("keydown", function(e) {
            if(e.key === "ArrowUp") {
                keyModifier = "set";
            } else if(e.key === "ArrowDown") {
                keyModifier = "unset";
            } else if(e.shiftKey) {
                e.preventDefault();
                keyModifier = "set";
            } else if(e.key === "Tab") {
                e.preventDefault();
                keyModifier = "unset";
            } else if(e.key === "Backspace") {
                // Clear all beads when Escape is pressed
                document.querySelectorAll('.bead').forEach(bead => {
                    applySwipeAction(bead, "unset");
                });
            } else if(e.key === "#") {
                // Toggle all beads when # is pressed
                document.querySelectorAll('.bead').forEach(bead => {
                    applySwipeAction(bead, "toggle");
                });
            } else if(e.key === "Enter") {
                // Toggle all beads when Enter is pressed
                document.querySelectorAll('.bead').forEach(bead => {
                    applySwipeAction(bead, "set");
                });
            }
        });

        window.addEventListener("keyup", function(e) {
            if(e.key === "ArrowUp" || e.key === "ArrowDown" || e.key === "Shift" || e.key === "Tab") {
                keyModifier = "";
            }
        });

        window.addEventListener("keydown", function(event) {
            let key = event.key.toLowerCase();
            keyMap.forEach((rowKeys, rowIndex) => {
                let pos = rowKeys.indexOf(key);
                if (pos !== -1 && rowIndex < rows) {
                    const rowElements = document.querySelectorAll('.abacus .row');
                    if (rowElements[rowIndex]) {
                        let beads = rowElements[rowIndex].querySelectorAll('.bead');
                        if (pos < beads.length) {
                            pos = pos + beads.length -8;
                            let bead = beads[pos];
                            let action = "toggle";
                            if (keyModifier.length) {
                                action = keyModifier;
                            }
                            applySwipeAction(bead, action);
                        }
                    }
                }
            });
        }, {capture: true});

        // --- End Swipe and Keyboard Input Functionality ---

        // Toggle keyboard overlay for beads when "Show Keyboard" button is clicked.
        let keyboardOverlay = false;
        document.getElementById('showKeyboard(Ctrl)').addEventListener('click', function() {
            keyboardOverlay = !keyboardOverlay;
            this.textContent = keyboardOverlay ? "Hide Keyboard" : "Show Keyboard";
            updateKeyboardOverlay(keyboardOverlay);
        });

        function updateKeyboardOverlay(showOverlay) {
            // Get all rows in the abacus
            const rowElements = document.querySelectorAll('.abacus .row');
            rowElements.forEach((rowElement, rowIndex) => {
                // Get the beads in this row.
                const beads = rowElement.querySelectorAll('.bead');
                // Calculate offset (if there are more than 8 columns, mapping starts at index = beads.length - 8)
                const offset = beads.length > 8 ? beads.length - 8 : 0;
                beads.forEach((bead, beadIndex) => {
                    // Remove any existing key-label to avoid duplicates.
                    const existingLabel = bead.querySelector('.key-label');
                    if (existingLabel) {
                        existingLabel.remove();
                    }
                    // If overlay is turned on and a mapping exists for this row...
                    if (showOverlay && rowIndex < keyMap.length) {
                        const keyStr = keyMap[rowIndex]; // e.g. "qwertyui"
                        const keyIndex = beadIndex - offset;
                        if (keyIndex >= 0 && keyIndex < keyStr.length) {
                            const letter = keyStr[keyIndex];
                            const label = document.createElement('span');
                            label.className = 'key-label';
                            label.textContent = letter;
                            bead.appendChild(label);
                        }
                    }
                });
            });
        }

        document.getElementById('hidePlaceValues').addEventListener('change', function() {
            generateAbacus(columns, rows);
        });
    </script>
</body>
</html> 